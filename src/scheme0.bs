(define-syntax define #%define-transformer)

(define (list . L) L)
(define (string . L) (list->string L))
(define (vector . L) (list->vector L))
(define (string-append . L) (#%string-append L))
(define (gensym . L) (#%gensym L))
(define (generate-temporaries xs)
  (if (null? xs)
      '()
      (cons (gensym) (generate-temporaries (cdr xs)))))

(define #%or-transformer
  (lambda (x)
    (if (= (length x) 1)
        #f
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t ,t (or ,@exps)))))))))

(define-syntax or #%or-transformer)

(define #%and-transformer
  (lambda (x)
    (if (= (length x) 1)
        #t
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t (and ,@exps) ,t))))))))

(define-syntax and #%and-transformer)

(define (not x) (if x #f #t))

(define (map p ls)
  (if (null? ls)
      '()
      (cons (p (car ls)) (map p (cdr ls)))))

(define (+ . ns)
  (if (null? ns)
      0
      (+/2 (car ns) (apply + (cdr ns)))))

(define (cadr ls) (list-ref ls 1))

(define (apply proc args) (#%apply proc args))

#;(define #%letrec-transformer
  (lambda (stx)
    (apply (lambda (_ bindings . bodies)
             (let ([vars (map car bindings)]
                   [exps (map cadr bindings)])
               `(let ,(map (lambda (v) `(,v #f)) vars)
                  foo)))
           stx)))

#;(define #%letrec-transformer
  (lambda (stx)
    (apply (lambda (lr bindings . bodies)
             (list lr bindings bodies))
stx)))

(define foo
  (lambda (stx)
    (apply
     (lambda (name bindings . bodies) (list name bindings bodies))
     stx)))
  
#;(define-syntax letrec #%letrec-transformer)

#;(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))
