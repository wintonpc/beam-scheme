(define-syntax define #%define-transformer)

(define (list . L) L)
(define (string . L) (list->string L))
(define (vector . L) (list->vector L))
(define (string-append . L) (#%string-append L))
(define (gensym . L) (#%gensym L))
(define (generate-temporaries xs)
  (if (null? xs)
      '()
      (cons (gensym) (generate-temporaries (cdr xs)))))

(define #%or-transformer
  (lambda (x)
    (if (= (length x) 1)
        #f
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t ,t (or ,@exps)))))))))

(define-syntax or #%or-transformer)

(define #%and-transformer
  (lambda (x)
    (if (= (length x) 1)
        #t
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t (and ,@exps) ,t))))))))

(define-syntax and #%and-transformer)

(define (not x) (if x #f #t))

(define (map1 p ls)
  (if (null? ls)
      '()
      (cons (p (car ls)) (map p (cdr ls)))))

(define (map p . lists)
  (if (null? (car lists))
      '()
      (cons (apply p (map1 car lists)) (apply map (cons p (map1 cdr lists))))))

(define (+ . ns)
  (if (null? ns)
      0
      (+/2 (car ns) (apply + (cdr ns)))))

(define (cadr ls) (list-ref ls 1))

(define (apply proc args) (#%apply proc args))

(define #%letrec-transformer
  (lambda (stx)
    (apply (lambda (_ bindings . bodies)
             (let ([vars (map car bindings)]
                   [exps (map cadr bindings)])
               (let ([tmps (generate-temporaries vars)])
                 `(let ,(map (lambda (v) `(,v #f)) vars)
                    (let ,(map (lambda (t e) (list t e)) tmps exps)
                      ,@(map (lambda (v t) `(set! ,v ,t)) vars tmps)
                      (let () ,@bodies))))))
           stx)))

(define-syntax letrec #%letrec-transformer)

#;(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))
