(define-syntax define #%define-transformer)

(define (list . L) L)
(define (mlist . L) (list->mlist L))
(define (string . L) (list->string L))
(define (vector . L) (list->vector L))
(define (string-append . L) (#%string-append L))
(define (gensym . L) (#%gensym L))
(define (values . L) (make-values L))
(define (call-with-values producer consumer)
  (apply consumer (values->list (producer))))

(define (mreverse ls)
  (mreverse2 ls '()))

(define (mreverse2 ls acc)
  (if (null? ls)
      acc
      (mreverse2 (mcdr ls) (mcons (mcar ls) acc))))

(define (mlength ls)
  (mlength2 ls 0))

(define (mlength2 ls acc)
  (if (null? ls)
      acc
      (mlength2 (mcdr ls) (+ acc 1))))

(define (mlist->string ls)
  (list->string (mlist->list ls)))

(define (mlist->vector ls)
  (list->vector (mlist->list ls)))

(define (vector->mlist v)
  (list->mlist (vector->list v)))

(define (cadr p) (car (cdr p)))

(define (generate-temporaries xs)
  (if (null? xs)
      '()
      (cons (gensym) (generate-temporaries (cdr xs)))))

(define #%or-transformer
  (lambda (x)
    (if (= (length x) 1)
        #f
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t ,t (or ,@exps)))))))))

(define-syntax or #%or-transformer)

(define #%and-transformer
  (lambda (x)
    (if (= (length x) 1)
        #t
        (let ((exp0 (car (cdr x)))
              (exps (cdr (cdr x))))
          (if (= (length x) 2)
              exp0
              (let ((t (gensym 't)))
                `(let ((,t ,exp0))
                   (if ,t (and ,@exps) ,t))))))))

(define-syntax and #%and-transformer)

(define (not x) (if x #f #t))

(define (map1 p ls)
  (if (null? ls)
      '()
      (cons (p (car ls)) (map p (cdr ls)))))

(define (map p . lists)
  (if (null? (car lists))
      '()
      (cons (apply p (map1 car lists)) (apply map (cons p (map1 cdr lists))))))

(define (+ . ns)
  (if (null? ns)
      0
      (+/2 (car ns) (apply + (cdr ns)))))

(define (cadr ls) (list-ref ls 1))

(define (apply proc args) (#%apply proc args))

(define #%letrec-transformer
  (lambda (stx)
    (apply (lambda (_ bindings . bodies)
             (let ([vars (map car bindings)]
                   [exps (map cadr bindings)])
               (let ([tmps (generate-temporaries vars)])
                 `(let ,(map (lambda (v) `(,v #f)) vars)
                    (let ,(map (lambda (t e) (list t e)) tmps exps)
                      ,@(map (lambda (v t) `(set! ,v ,t)) vars tmps)
                      (let () ,@bodies))))))
           stx)))

(define-syntax letrec #%letrec-transformer)

(define append
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (car args) (cdr args))
                (cons (car ls) (g (cdr ls)))))))))

(define mappend
  (lambda args
    (let f ([ls '()] [args args])
      (if (null? args)
          ls
          (let g ([ls ls])
            (if (null? ls)
                (f (mcar args) (mcdr args))
                (mcons (mcar ls) (g (mcdr ls)))))))))

;; (define (cons* . args)
;;   (cond
;;    [(null? args) '()]
;;    [(null? (cdr args)) (car args)]
;;    [else (cons (car args) (apply cons* (cdr args)))]))

(define-syntax delay
  (lambda (stx)
    `(lambda () ,(cadr stx))))

(define (force promise) (promise))

(define (take-stream n s)
  (if (= n 0)
      '()
      (cons (car s) (take-stream (- n 1) (force (cdr s))))))
